<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Liu Qi's Blog</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 12 Jul 2016 21:12:28 +0800</pubDate>
    <lastBuildDate>Tue, 12 Jul 2016 21:12:28 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Blockchain and Bitcoin (1)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;
&lt;p&gt;Bitcoin is a peer-to-peer digital asset and a payment system. The system is invented by &lt;a href=&quot;https://en.wikipedia.org/wiki/Satoshi_Nakamoto&quot;&gt;Satoshi Nakamoto&lt;/a&gt; and released as an open-source software in 2009.&lt;/p&gt;

&lt;p&gt;Bitcoins are created as a reward for payment processing work in which users offer their computing power to verify and record payments into a public ledger. This activity is called mining and miners are rewarded with transaction fees and newly created bitcoins. Besides being obtained by mining, bitcoins can be exchanged for other currencies, products, and services.&lt;/p&gt;

&lt;p&gt;Bitcoin is revolutionising they way people pay and exchange products. In former days, currency is created and exchanged based on trusted institutions. The central bank issues currency and people make their payments via various ways such as commercial bank, PayPal, Alipay, Apple Wallet, etc. This centralised scheme has its own problems like counterfeit. On the contrary, In bitcoin system, transactions take place between users directly, without an intermediary. These transactions are verified by network nodes and recorded in a public distributed ledger called the blockchain.&lt;/p&gt;

&lt;p&gt;This blog series is based on some excellent books and tutorials such as &lt;a href=&quot;http://shop.oreilly.com/product/0636920032281.do&quot;&gt;Master Bitcoin&lt;/a&gt; and &lt;a href=&quot;https://www.coursera.org/learn/cryptocurrency&quot;&gt;Bitcoin and Cryptocurrency Technologies&lt;/a&gt;. The &lt;a href=&quot;https://en.bitcoin.it/wiki/Protocol_documentation&quot;&gt;official documentation&lt;/a&gt; of bitcoin is also very helpful.&lt;/p&gt;

&lt;p&gt;In the first post, we give some introduction on data structures and cryptography concepts used in blockchain and bitcoin.&lt;/p&gt;

&lt;h3 id=&quot;cryptographic-hash-function&quot;&gt;2. Cryptographic Hash function&lt;/h3&gt;

&lt;h4 id=&quot;properties&quot;&gt;2.1 Properties&lt;/h4&gt;
&lt;p&gt;Cryptographic Hash function is used often in blockchain. For a hash function, it takes variable length input &lt;em&gt;x&lt;/em&gt; and map it to a fixed size output &lt;em&gt;H(x)&lt;/em&gt; (e.g. 256 bits for MD5 and SHA-256). A hash function must have three properties to become a cryptographic hash function:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Collision-resistance: A hash function &lt;em&gt;H&lt;/em&gt; is said to be collision resistant if it is infeasible to find two values, &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; , such that &lt;em&gt;x != y&lt;/em&gt; , yet &lt;em&gt;H(x)= H(y)&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hiding: A hash function &lt;em&gt;H&lt;/em&gt; is hiding if: when a secret value &lt;em&gt;r&lt;/em&gt; is chosen from a probability distribution that has high entropy, then given &lt;em&gt;H(r ‖ x)&lt;/em&gt; it is infeasible to find &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;‖&lt;/em&gt; means concatenation of two strings.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Puzzle friendliness. A hash function &lt;em&gt;H&lt;/em&gt; is said to be puzzle-friendly if for every possible n-bit output value &lt;em&gt;y&lt;/em&gt; , if &lt;em&gt;k&lt;/em&gt; is chosen from a distribution with high entropy, then it is infeasible to find &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;H(k ‖ x) = y&lt;/em&gt; in time significantly less than &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given three properties, those hash functions can have a lot of practical applications. Hiding and puzzle friendliness guaranttee that it is infeasible to reverse-engineer intput &lt;em&gt;x&lt;/em&gt; given hash value &lt;em&gt;H(x)&lt;/em&gt;. In Blockchain system, SHA-256 is the hardcore of the system. Given a data block, SHA-256 maps the data block to 256 bits. According to collision-resistance, since it is infeasible to find two different values that are mapped to the same hash value, we can safely use the 256 bits as the ID of the data block. SHA-256 is generated by a procedure called &lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction&quot;&gt;Merkle-Damgard transform&lt;/a&gt;. The procedure is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/sha256.png&quot; width=&quot;400&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hash-pointers&quot;&gt;2.2 Hash Pointers&lt;/h4&gt;
&lt;p&gt;A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. Whereas a regular pointer gives you a way to retrieve the information, a hash pointer also gives you a way to verify that the information hasn’t changed. In regular pointer such as in C/C++, the pointer stores the variable address. In a hash pointer, it simply stores the hash value &lt;em&gt;H(x)&lt;/em&gt; of the data &lt;em&gt;x&lt;/em&gt; it points to. An example is shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/hashpointer.png&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In practice, the hash pointers can be indexed by database or structures like hash table to support efficient retrieval. Given hash pointers, we can use it to build all kinds of data structures. Intuitively, we can take a familiar data structure that uses pointers such as a linked list or a binary search tree and implement it with hash pointers, instead of pointers as we normally would. Here is two examples on blockchain and merkle tree.&lt;/p&gt;

&lt;h5 id=&quot;blockchain&quot;&gt;2.2.1 Blockchain&lt;/h5&gt;
&lt;p&gt;Blockchain is just a linked list using hash pointers. Whereas as in a regular linked list where you have a series of blocks, each block has data as well as a pointer to the previous block in the list, in a block chain the previous block pointer will be replaced with a hash pointer. So each block not only tells us where the value of the previous block was, but it also contains a digest of that value that allows us to verify that the value hasn’t changed. We store the head of the list, which is just a regular hash-pointer that points to the most recent data block.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/blockchain.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structures have the property that it is a tamper-evident log, i.e., if the attacher changes the data in the middle, he has to continue changing the hash pointers until the root of the blockchain. In a distributed environment, if others store a copy of the root of the blockchain, it can easily detect the blockchain in the attacker’s machine has been tampered.&lt;/p&gt;

&lt;h5 id=&quot;merkle-trees&quot;&gt;2.2.2 Merkle trees&lt;/h5&gt;
&lt;p&gt;Another useful data structure that we can build using hash pointers is a binary tree. A binary tree with hash pointers is known as a Merkle tree, after its inventor Ralph Merkle. Suppose we have a number of blocks containing data. These blocks comprise the leaves of our tree. We group these data blocks into pairs of two, and then for each pair, we build a data structure that has two hash pointers, one to each of these blocks. These data structures make the next level up of the tree. We in turn group these into groups of two, and for each pair, create a new data structure that contains the hash of each. We continue doing this until we reach a single block, the root of the tree. For example, suppose we have three data blocks, &lt;em&gt;a, b, c&lt;/em&gt;. We can generate a merkle tree by doing the following steps:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d1 = dhash(a)&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;d2 = dhash(b)&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;d3 = dhash(c)&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;d4 = dhash(c)&lt;/em&gt; &lt;em&gt;#since we have odd number of blocks, we append it with another c&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d5 = dhash(d1 concat d2)&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;d6 = dhash(d3 concat d4)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d7 = dhash(d5 concat d6)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is graphical example of merkle tree with 8 data blocks.&lt;br /&gt;
&lt;img src=&quot;/images/post1/merkle.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on the structure of merkle, it can check the membership of data in &lt;em&gt;O(logn)&lt;/em&gt; time and &lt;em&gt;O(logn)&lt;/em&gt; space. Here is a nice post from &lt;a href=&quot;https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work&quot;&gt;Quora&lt;/a&gt; illustrating why.&lt;/p&gt;

&lt;h3 id=&quot;signatures&quot;&gt;3 Signatures&lt;/h3&gt;
&lt;p&gt;A digital signature is supposed to be the digital analog to a handwritten signature on paper. We desire two properties from digital signatures that correspond well to the handwritten signature analogy. Firstly, only you can make your signature, but anyone who sees it can verify that it’s valid. Secondly, we want the signature to be tied to a particular document so that the signature cannot be used to indicate your agreement or endorsement of a different document. For handwritten signatures, this latter property is analogous to assuring that somebody can’t take your signature and snip it off one document and glue it onto the bottom of another one.&lt;/p&gt;

&lt;p&gt;In practice, the signature is usually implemented as private-public key encryption. The popular algorithm is &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot;&gt;RSA&lt;/a&gt;. A digital signature scheme consists of the following three algorithms:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;(sk, pk) := generateKeys(keysize)&lt;/em&gt; The generateKeys method takes a key size and generates a key pair. The secret key &lt;em&gt;sk&lt;/em&gt; is kept privately and used to sign messages. &lt;em&gt;pk&lt;/em&gt; is the public verification key that you give to everybody. Anyone with this key can verify your signature.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;sig := sign(sk, message)&lt;/em&gt; The sign method takes a message, &lt;em&gt;msg&lt;/em&gt;, and a secret key, &lt;em&gt;sk&lt;/em&gt;, as input and outputs a signature for the &lt;em&gt;msg&lt;/em&gt; under &lt;em&gt;sk&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;isValid := verify(pk, message, sig)&lt;/em&gt; The verify method takes a message, a signature, and a public key as input. It returns a boolean value, &lt;em&gt;isValid&lt;/em&gt;, that will be true if &lt;em&gt;sig&lt;/em&gt; is a valid signature for message under public key &lt;em&gt;pk&lt;/em&gt;, and false otherwise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We require that the following two properties hold:&lt;br /&gt;
1. Valid signatures must verify: &lt;em&gt;verify(pk, message, sign(sk, message))== true&lt;/em&gt;&lt;br /&gt;
2. Signatures are existentially unforgeable&lt;/p&gt;

&lt;p&gt;With signature, the receiver of the message can verify the validity.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;Given the building blocks of blockchain and bitcoin, in next post, we will introduce the format of blockchain data and other more advanced features.&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/12/Blockchain-and-Bitcoin-(1).html</link>
        <guid isPermaLink="true">/2016/07/12/Blockchain-and-Bitcoin-(1).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>data-structure</category>
        
        <category>cryptography</category>
        
        
      </item>
    
  </channel>
</rss>
