<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Liu Qi's Blog</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 19 Jul 2016 20:10:31 +0800</pubDate>
    <lastBuildDate>Tue, 19 Jul 2016 20:10:31 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Blockchain and Bitcoin (3)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;

&lt;p&gt;In this post, we will look at real data structures of blocks and transactions, real scripts Bitcoin use. Let’s start with transaction structures. The figure below shows the data structure of a transaction.&lt;br /&gt;
&lt;img src=&quot;/images/post3/transaction.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;br /&gt;
To view the real transactions happening in Bitcoin network, some websites can be referred to such as &lt;a href=&quot;https://blockchain.info/&quot;&gt;blockchain.info&lt;/a&gt;. As we can see from the figure, there are three parts to a transaction: some metadata, a series of inputs, and a series of outputs.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Metadata&lt;/em&gt;. There’s some housekeeping information — the size of the transaction, the number of inputs, and the number of outputs. There’s the hash of the entire transaction which serves as a unique ID for the transaction. That’s what allows us to use hash pointers to reference transactions. Finally there’s a “lock_time” field. The way it works is that if you specify any value other than zero for the lock time, it tells miners not to publish the transaction until the specified lock time. The transaction will be invalid before either a specific block number, or a specific point in time, based on the timestamps that are put into blocks. So this is a way of preparing a transaction that can only be spent in the future if it isn’t already spent by then.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Inputs&lt;/em&gt;. The transaction inputs form an array, and each input has the same form. An input specifies a previous transaction, so it contains a hash of that transaction, which acts as a hash pointer to it. The input also contains the index of the previous transaction’s outputs that’s being claimed. And then there’s a signature script: scriptSig which we will talk about it later. Remember that we have to sign to show that we actually have the ability to claim those previous transaction outputs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Outputs&lt;/em&gt;. The outputs are again an array. Each output has just two fields. They each have a value, and the sum of all the output values has to be less than or equal to the sum of all the input values. If the sum of the output values is less than the sum of the input values, the difference is a transaction fee to the miner who publishes this transaction. The other field is scriptPubKey script.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;bitcoin-scripts&quot;&gt;2. Bitcoin Scripts&lt;/h3&gt;
&lt;p&gt;In this section, we will talk about the two scripts: scriptSig and scriptPubKey.&lt;/p&gt;

&lt;p&gt;The most common type of transaction in Bitcoin is to redeem a previous transaction output by signing with the correct key. In this case, we want the transaction output to say, “this can be redeemed by a signature from the owner of address X.” An address is a hash of a public key. So merely specifying the address X doesn’t tell us what the public key is, and doesn’t give us a way to check the signature. So instead the transaction output must say “this can be redeemed by a public key that hashes to X, along with a signature from the owner of that public key.”&lt;/p&gt;

&lt;p&gt;We concatenate the two scripts, and the resulting script must run successfully in order for the transaction to be valid. In the simplest case, the scriptPubKey just specifies a public key (or an address to which the public key hashes), and scriptSig specifies a signature with that public key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post3/script.png&quot; width=&quot;200&quot; height=&quot;150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;An example of combined script is shown above. The first part is scriptSig and the second part is scriptPubKey. The script is a stack based language and it does not have loop in it. Thus, we just need to run it line by line to check its validity. There are only two possible outcomes when a Bitcoin script is executed. It either executes successfully with no errors, in which case the transaction is valid. Or, if there’s any error while the script is executing, the whole transaction will be invalid and shouldn’t be accepted into the block chain. Some commonly used commands are shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post3/command.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To execute a script in a stack-based programming language, all we’ll need is a stack that we can push data to and pop data from. The figure below illustrates what happens to the stack after each operation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post3/runtime.png&quot; width=&quot;700&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Bitcoin scripting language is very small. There’s only room for 256 instructions, because each one is represented by one byte. Of those 256, 15 are currently disabled, and 75 are reserved. The reserved instruction codes haven’t been assigned any specific meaning yet, but might be instructions that are added later in time. Although this stack based language is not Turing-complete, it still makes Bitcoin more programmable and flexible. It has many applications such green address, escrow transactions, smart contract…&lt;/p&gt;

&lt;h3 id=&quot;block-structure&quot;&gt;3. Block Structure&lt;/h3&gt;
&lt;p&gt;The block chain is a clever combination of two different hash-based data structures. The first is a hash chain of blocks. Each block has a block header, a hash pointer to some transaction data, and a hash pointer to the previous block in the sequence. The second data structure is a per-block tree of all of the transactions that are included in that block. This is a Merkle tree and allows us to have a digest of all the transactions in the block in an efficient way. The figure below shows an example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post3/blockchain.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A block in block chain mainly has a header and a list of transactions. The format of the header is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post3/header.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The transactions are accumulated in 10 minutes and put into one block for efficiency reasons. There is a special type of transaction called coinbase which is the transaction that generates new Bitcoins. It mostly looks like a normal transaction but with several differences: (1) it always has a single input and a single output, (2) the input doesn’t redeem a previous output and thus contains a null hash pointer, since it is minting new bitcoins and not spending existing coins, (3) the value of the output is currently a little over 25 Bitcoins. The output value is the miner’s revenue from the block. It consists of two components: a flat mining reward, which is set by the system and which halves every 210,000 blocks (about 4 years), and the transaction fees collected from every transaction included in the block. (4) There is a special “coinbase” parameter, which is completely arbitrary — miners can put whatever they want in there.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;This post introduces how the data structures of Bitcoin transactions and blocks. In next post, we will talk about the security and applications of Blockchain.&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/19/Blockchain-and-Bitcoin-(3).html</link>
        <guid isPermaLink="true">/2016/07/19/Blockchain-and-Bitcoin-(3).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>transaction</category>
        
        <category>block-format</category>
        
        <category>data-structure</category>
        
        
      </item>
    
      <item>
        <title>Blockchain and Bitcoin (2)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;

&lt;p&gt;We will discuss decentralization of Bitcoin in this post. The scheme is first proposed in the &lt;a href=&quot;https://bitcoin.org/bitcoin.pdf&quot;&gt;whitepaper&lt;/a&gt; published by Satoshi. In peer-to-peer cryptocurrency systems, lots of obstacles arise compared to centralised systems such as latency of network, double-spend-attack, loss of data etc. Because of those constraints, Bitcoin does not purely rely on technical methods to achieve decentralisation, but it’s a combination of technical methods and clever incentive engineering. In this post, we first give the simplied protocol Bitcoin used and then elaborate on this protocol.&lt;/p&gt;

&lt;h3 id=&quot;distributed-consensus-protocol&quot;&gt;2. Distributed consensus protocol&lt;/h3&gt;
&lt;p&gt;Imagine you’re in charge of the backend for a large social networking company like Facebook. Systems of this sort typically have thousands or even millions of servers, which together form a massive distributed database that records all of the actions that happen in the system. Each piece of information must be recorded on several different nodes in this backend, and the nodes must be in sync about the overall state of the system. Thus, a consensus protocol is needed in this context. A distributed consensus protocol should have two properties as discussed below:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Distributed consensus protocol&lt;/b&gt;: There are n nodes that each have an input value. Some of these nodes are faulty or malicious. A distributed consensus protocol has the following two properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;It must terminate with all honest nodes in agreement on the value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The value must have been generated by an honest node&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, distributed consensus protocol plays a central role in the design of distributed systems. However, the lack of global time heavily constrains the set of algorithms that can be used in the consensus protocols. In fact, because of these constraints, much of the literature on distributed consensus is somewhat pessimistic, and many impossibility results have been proven. One very well known impossibility result is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Byzantine_fault_tolerance&quot;&gt;Byzantine Generals Problem&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;blockchain-protocol&quot;&gt;2.1 Blockchain protocol&lt;/h4&gt;
&lt;p&gt;Bitcoin uses Blockchain to record the transactions. Thus, Blockchain needs protocol to sync the blocks for nodes in the network. Suppose there is somehow an ability to pick a random node in the system (in Bitcoin, this random node is picked by a procedure called mining), this node gets to propose the next block in the chain. Here is the simplified protocol.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Bitcoin consensus algorithm (simplified)&lt;/b&gt;&lt;br /&gt;
This algorithm is simplified in that it assumes the ability to select a random node in a manner that is not vulnerable to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sybil_attack&quot;&gt;Sybil attacks&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;New transactions are broadcast to all nodes&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each node collects new transactions into a block&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In each round a random node gets to broadcast its block&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other nodes accept the block only if all transactions in it are valid (unspent, valid signatures)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nodes express their acceptance of the block by including its hash in the next block they create&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By this manner, the system is robust enough to prevent potential attacks which we will talk about later. First, we will talk about how other nodes process the block they received a block(step 4 and step 5).&lt;/p&gt;

&lt;h4 id=&quot;receive-block&quot;&gt;2.1.1 Receive block&lt;/h4&gt;
&lt;p&gt;When receiving a new block message broadcasted from step 3, the node should extend the blockchain they are maintaining. There are three kinds of blocks in the blockchain:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;blocks in the main branch. The transactions in these blocks are considered at least tentatively confirmed&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;blocks on side branches off the main branch. These blocks have at least tentatively lost the race to be in the main branch&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;orphan blocks. These are blocks which don’t link into the main branch, normally because of a missing predecessor or nth-level predecessor.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The largest branch in the blockchain is called the main branch. When receiving a new block, the node will try to add this into main branch, side branches or orphan block pool depending on the hash pointer. After adding it, three cases will arise:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;block further extends the main branch;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block extends a side branch but does not add enough difficulty to make it become the new main branch;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block extends a side branch and makes it the new main branch.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Depending on which case happens, the blockchain takes different actions. An overview of the actions is available at &lt;a href=&quot;https://en.bitcoin.it/wiki/Protocol_rules&quot;&gt;protocol&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;advantages&quot;&gt;2.1.2 Advantages&lt;/h4&gt;
&lt;p&gt;The protocol can prevent many kinds of attacks. Let’s now try to understand why this consensus algorithm works. To do this, let’s consider how a malicious adversary — who we’ll call Alice — may be able to subvert this process.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Stealing Bitcoins.&lt;/b&gt; Can Alice simply steal bitcoins belonging to another user at an address she doesn’t control? No. Even if it is Alice’s turn to propose the next block in the chain, she cannot steal other users’ bitcoins. Doing so would require Alice to create a valid transaction that spends that coin. This would require Alice to forge the owners’ signatures which she cannot do if a secure digital signature scheme is used. So as long as the underlying cryptography is solid, she’s not able to simply steal bitcoins.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Denial of service attack.&lt;/b&gt; Let’s consider another attack. Say Alice really dislikes some other user Bob. Alice can then decide that she will not include any transactions originating from Bob’s address in any block that she proposes to get onto the block chain. In other words, she’s denying service to Bob. While this is a valid attack that Alice can try to mount, luckily it’s nothing more than a minor&lt;br /&gt;
annoyance. If Bob’s transaction doesn’t make it into the next block that Alice proposes, he will just wait until an honest node gets the chance to propose a block and then his transaction will get into that block. So that’s not really a good attack either.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Double-spend attack.&lt;/b&gt; Let’s assume that Alice is a customer of some online merchant or website run by Bob, who provides some online service in exchange for payment in bitcoins. Let’s say Bob’s service allows the download of some software. So here’s how a double-spend attack might work. Alice adds an item to her shopping cart on Bob’s website and the server requests payment. Then Alice creates a Bitcoin transaction from her address to Bob’s and broadcasts it to the network. Let’s say that some honest node creates the next block, and includes this transaction in that block. So there is now a block that was created by an honest node that contains a transaction that represents a payment from Alice to the merchant Bob. The graph below shows the effect to Blockchain.&lt;br /&gt;
&lt;img src=&quot;/images/post2/doublespend.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And how do we know if this double spend attempt is going to succeed or not? Well, that depends on which block will ultimately end up on the long-term consensus chain — the one with the Alice → Bob transaction or the one with the Alice → Alice transaction. What determines which block will be included? Honest nodes follow the policy of extending the longest valid branch, so which branch will they extend? There is no right answer! At this point, the two branches are the same length — they only differ in the last block and both of these blocks are valid. The node that chooses the next block then may decide to build upon either one of them. Thus, only one of two transactions will finally be kept in the blockchain. Alice cannot achieve double-spend attack in this context. The merchart Bob can wait confirmations for transactions to decide whether let Alice download the software. Thus, the protocol can prevent double-spend attack.&lt;/p&gt;

&lt;h3 id=&quot;pick-up-a-random-node&quot;&gt;3. Pick up a random node&lt;/h3&gt;
&lt;p&gt;In this section, we will talk about how to randomly choose a node from the network. Nodes in the network are rewarded by being chosen as this node. Thus, this motivates people to get the opportunity for being chosen through ‘mining’. The rewards include the creation of new coins and transaction fees. At the time of this writing, the value of the block reward is fixed at 25 Bitcoins. But it actually halves every 210,000 blocks. Based on the rate of block creation that we will see shortly, this means that the rate drops roughly every four years (because in expection, a new block is generated every 10 minutes). We’re now in the second period. For the first four years of Bitcoin’s existence, the block reward was 50 bitcoins; now it’s 25. The node chosen will get 25 newly created Bitcoins. &lt;br /&gt;
&lt;img src=&quot;/images/post2/reward.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, we introduce how the node is chosen through ‘mining’. The node is chosen through proof-of-work. The key idea behind proof-of-work is that we approximate the selection of a random node by instead selecting nodes in proportion to a resource that we hope that nobody can monopolize. If, for example, that resource is computing power, then it’s a proof-of-work system.&lt;/p&gt;

&lt;p&gt;Bitcoin achieves proof-of-work using hash puzzles. In order to create a block, the node that proposes that block is required to find a number, or nonce, such that when you concatenate the nonce, the previous hash, and the list of transactions that comprise that block and take the hash of this whole string, then that hash output should be a number that falls into a target space that is quite small in relation to the much larger output space of that hash function. We can define such a target space as any value falling below a certain target value. In this case, the nonce will have to satisfy the inequality:&lt;/p&gt;
&lt;center&gt;H(nonce || prev_hash || tx || tx || ... || tx) &amp;lt; target.&lt;/center&gt;

&lt;p&gt;The first node which finds this nonce proposes the block. Thus, in order to be chosen, the node should have a great computing power. The incentive to get Bitcoins flourishes the Bitcoin mining industry.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;This post introduces how Bitcoin achieves concensus and how to choose random node to propose next block. In next post, we will introduce the data format of blocks.&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/16/Blockchain-and-Bitcoin-(2).html</link>
        <guid isPermaLink="true">/2016/07/16/Blockchain-and-Bitcoin-(2).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>consensus-algorithm</category>
        
        <category>double-spend-attack</category>
        
        <category>decentralisation</category>
        
        
      </item>
    
      <item>
        <title>Blockchain and Bitcoin (1)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;
&lt;p&gt;Bitcoin is a peer-to-peer digital asset and a payment system. The system is invented by &lt;a href=&quot;https://en.wikipedia.org/wiki/Satoshi_Nakamoto&quot;&gt;Satoshi Nakamoto&lt;/a&gt; and released as an open-source software in 2009.&lt;/p&gt;

&lt;p&gt;Bitcoins are created as a reward for payment processing work in which users offer their computing power to verify and record payments into a public ledger. This activity is called mining and miners are rewarded with transaction fees and newly created bitcoins. Besides being obtained by mining, bitcoins can be exchanged for other currencies, products, and services.&lt;/p&gt;

&lt;p&gt;Bitcoin is revolutionising they way people pay and exchange products. In former days, currency is created and exchanged based on trusted institutions. The central bank issues currency and people make their payments via various ways such as commercial bank, PayPal, Alipay, Apple Wallet, etc. This centralised scheme has its own problems like counterfeit. On the contrary, In bitcoin system, transactions take place between users directly, without an intermediary. These transactions are verified by network nodes and recorded in a public distributed ledger called the blockchain.&lt;/p&gt;

&lt;p&gt;This blog series is based on some excellent books and tutorials such as &lt;a href=&quot;http://shop.oreilly.com/product/0636920032281.do&quot;&gt;Master Bitcoin&lt;/a&gt; and &lt;a href=&quot;https://www.coursera.org/learn/cryptocurrency&quot;&gt;Bitcoin and Cryptocurrency Technologies&lt;/a&gt;. The &lt;a href=&quot;https://en.bitcoin.it/wiki/Protocol_documentation&quot;&gt;official documentation&lt;/a&gt; of bitcoin is also very helpful.&lt;/p&gt;

&lt;p&gt;In the first post, we give some introduction on data structures and cryptography concepts used in blockchain and bitcoin.&lt;/p&gt;

&lt;h3 id=&quot;cryptographic-hash-function&quot;&gt;2. Cryptographic Hash function&lt;/h3&gt;

&lt;h4 id=&quot;properties&quot;&gt;2.1 Properties&lt;/h4&gt;
&lt;p&gt;Cryptographic Hash function is used often in blockchain. For a hash function, it takes variable length input &lt;em&gt;x&lt;/em&gt; and map it to a fixed size output &lt;em&gt;H(x)&lt;/em&gt; (e.g. 256 bits for MD5 and SHA-256). A hash function must have three properties to become a cryptographic hash function:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Collision-resistance: A hash function &lt;em&gt;H&lt;/em&gt; is said to be collision resistant if it is infeasible to find two values, &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; , such that &lt;em&gt;x != y&lt;/em&gt; , yet &lt;em&gt;H(x)= H(y)&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hiding: A hash function &lt;em&gt;H&lt;/em&gt; is hiding if: when a secret value &lt;em&gt;r&lt;/em&gt; is chosen from a probability distribution that has high entropy, then given &lt;em&gt;H(r ‖ x)&lt;/em&gt; it is infeasible to find &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;‖&lt;/em&gt; means concatenation of two strings.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Puzzle friendliness. A hash function &lt;em&gt;H&lt;/em&gt; is said to be puzzle-friendly if for every possible n-bit output value &lt;em&gt;y&lt;/em&gt; , if &lt;em&gt;k&lt;/em&gt; is chosen from a distribution with high entropy, then it is infeasible to find &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;H(k ‖ x) = y&lt;/em&gt; in time significantly less than &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given three properties, those hash functions can have a lot of practical applications. Hiding and puzzle friendliness guaranttee that it is infeasible to reverse-engineer intput &lt;em&gt;x&lt;/em&gt; given hash value &lt;em&gt;H(x)&lt;/em&gt;. In Blockchain system, SHA-256 is the hardcore of the system. Given a data block, SHA-256 maps the data block to 256 bits. According to collision-resistance, since it is infeasible to find two different values that are mapped to the same hash value, we can safely use the 256 bits as the ID of the data block. SHA-256 is generated by a procedure called &lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction&quot;&gt;Merkle-Damgard transform&lt;/a&gt;. The procedure is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/sha256.png&quot; width=&quot;400&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hash-pointers&quot;&gt;2.2 Hash Pointers&lt;/h4&gt;
&lt;p&gt;A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. Whereas a regular pointer gives you a way to retrieve the information, a hash pointer also gives you a way to verify that the information hasn’t changed. In regular pointer such as in C/C++, the pointer stores the variable address. In a hash pointer, it simply stores the hash value &lt;em&gt;H(x)&lt;/em&gt; of the data &lt;em&gt;x&lt;/em&gt; it points to. An example is shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/hashpointer.png&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In practice, the hash pointers can be indexed by database or structures like hash table to support efficient retrieval. Given hash pointers, we can use it to build all kinds of data structures. Intuitively, we can take a familiar data structure that uses pointers such as a linked list or a binary search tree and implement it with hash pointers, instead of pointers as we normally would. Here is two examples on blockchain and merkle tree.&lt;/p&gt;

&lt;h5 id=&quot;blockchain&quot;&gt;2.2.1 Blockchain&lt;/h5&gt;
&lt;p&gt;Blockchain is just a linked list using hash pointers. Whereas as in a regular linked list where you have a series of blocks, each block has data as well as a pointer to the previous block in the list, in a block chain the previous block pointer will be replaced with a hash pointer. So each block not only tells us where the value of the previous block was, but it also contains a digest of that value that allows us to verify that the value hasn’t changed. We store the head of the list, which is just a regular hash-pointer that points to the most recent data block.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/blockchain.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structures have the property that it is a tamper-evident log, i.e., if the attacher changes the data in the middle, he has to continue changing the hash pointers until the root of the blockchain. In a distributed environment, if others store a copy of the root of the blockchain, it can easily detect the blockchain in the attacker’s machine has been tampered.&lt;/p&gt;

&lt;h5 id=&quot;merkle-trees&quot;&gt;2.2.2 Merkle trees&lt;/h5&gt;
&lt;p&gt;Another useful data structure that we can build using hash pointers is a binary tree. A binary tree with hash pointers is known as a Merkle tree, after its inventor Ralph Merkle. Suppose we have a number of blocks containing data. These blocks comprise the leaves of our tree. We group these data blocks into pairs of two, and then for each pair, we build a data structure that has two hash pointers, one to each of these blocks. These data structures make the next level up of the tree. We in turn group these into groups of two, and for each pair, create a new data structure that contains the hash of each. We continue doing this until we reach a single block, the root of the tree. For example, suppose we have three data blocks, &lt;em&gt;a, b, c&lt;/em&gt;. We can generate a merkle tree by doing the following steps:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d1 = dhash(a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d2 = dhash(b)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d3 = dhash(c)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d4 = dhash(c)&lt;/em&gt; &lt;em&gt;#since we have odd number of blocks, we append it with another c&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d5 = dhash(d1 ‖ d2)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d6 = dhash(d3 ‖ d4)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d7 = dhash(d5 ‖ d6)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is graphical example of merkle tree with 8 data blocks.&lt;br /&gt;
&lt;img src=&quot;/images/post1/merkle.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on the structure of merkle, it can check the membership of data in &lt;em&gt;O(logn)&lt;/em&gt; time and &lt;em&gt;O(logn)&lt;/em&gt; space. Here is a nice post from &lt;a href=&quot;https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work&quot;&gt;Quora&lt;/a&gt; illustrating why.&lt;/p&gt;

&lt;h3 id=&quot;signatures&quot;&gt;3. Signatures&lt;/h3&gt;
&lt;p&gt;A digital signature is supposed to be the digital analog to a handwritten signature on paper. We desire two properties from digital signatures that correspond well to the handwritten signature analogy. Firstly, only you can make your signature, but anyone who sees it can verify that it’s valid. Secondly, we want the signature to be tied to a particular document so that the signature cannot be used to indicate your agreement or endorsement of a different document. For handwritten signatures, this latter property is analogous to assuring that somebody can’t take your signature and snip it off one document and glue it onto the bottom of another one.&lt;/p&gt;

&lt;p&gt;In practice, the signature is usually implemented as private-public key encryption. The popular algorithm is &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot;&gt;RSA&lt;/a&gt;. A digital signature scheme consists of the following three algorithms:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;(sk, pk) := generateKeys(keysize)&lt;/em&gt; The generateKeys method takes a key size and generates a key pair. The secret key &lt;em&gt;sk&lt;/em&gt; is kept privately and used to sign messages. &lt;em&gt;pk&lt;/em&gt; is the public verification key that you give to everybody. Anyone with this key can verify your signature.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;sig := sign(sk, message)&lt;/em&gt; The sign method takes a message, &lt;em&gt;msg&lt;/em&gt;, and a secret key, &lt;em&gt;sk&lt;/em&gt;, as input and outputs a signature for the &lt;em&gt;msg&lt;/em&gt; under &lt;em&gt;sk&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;isValid := verify(pk, message, sig)&lt;/em&gt; The verify method takes a message, a signature, and a public key as input. It returns a boolean value, &lt;em&gt;isValid&lt;/em&gt;, that will be true if &lt;em&gt;sig&lt;/em&gt; is a valid signature for message under public key &lt;em&gt;pk&lt;/em&gt;, and false otherwise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We require that the following two properties hold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Valid signatures must verify: &lt;em&gt;verify(pk, message, sign(sk, message))== true&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Signatures are existentially unforgeable&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With signature, the receiver of the message can verify the validity.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;Given the building blocks of blockchain and bitcoin, in next post, we will introduce the consensus and decentralisation schemes of blockchain and other more advanced features.&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/12/Blockchain-and-Bitcoin-(1).html</link>
        <guid isPermaLink="true">/2016/07/12/Blockchain-and-Bitcoin-(1).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>data-structure</category>
        
        <category>cryptography</category>
        
        
      </item>
    
  </channel>
</rss>
