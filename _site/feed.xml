<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Liu Qi's Blog</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 16 Jul 2016 21:11:09 +0800</pubDate>
    <lastBuildDate>Sat, 16 Jul 2016 21:11:09 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Blockchain and Bitcoin (2)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;

&lt;p&gt;We will discuss decentralization of Bitcoin in this post. The scheme is first proposed in the &lt;a href=&quot;https://bitcoin.org/bitcoin.pdf&quot;&gt;whitepaper&lt;/a&gt; published by Satoshi. In peer-to-peer cryptocurrency systems, lots of obstacles arise compared to centralised systems such as latency of network, double-spend-attack, loss of data etc. Because of those constraints, Bitcoin does not purely rely on technical methods to achieve decentralisation, but it’s a combination of technical methods and clever incentive engineering. In this post, we first give the simplied protocol Bitcoin used and then elaborate on this protocol.&lt;/p&gt;

&lt;h3 id=&quot;distributed-consensus-protocol&quot;&gt;2. Distributed consensus protocol&lt;/h3&gt;
&lt;p&gt;Imagine you’re in charge of the backend for a large social networking company like Facebook. Systems of this sort typically have thousands or even millions of servers, which together form a massive distributed database that records all of the actions that happen in the system. Each piece of information must be recorded on several different nodes in this backend, and the nodes must be in sync about the overall state of the system. Thus, a consensus protocol is needed in this context. A distributed consensus protocol should have two properties as discussed below:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Distributed consensus protocol&lt;/b&gt;: There are n nodes that each have an input value. Some of these nodes are faulty or malicious. A distributed consensus protocol has the following two properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;It must terminate with all honest nodes in agreement on the value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The value must have been generated by an honest node&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, distributed consensus protocol plays a central role in the design of distributed systems. However, the lack of global time heavily constrains the set of algorithms that can be used in the consensus protocols. In fact, because of these constraints, much of the literature on distributed consensus is somewhat pessimistic, and many impossibility results have been proven. One very well known impossibility result is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Byzantine_fault_tolerance&quot;&gt;Byzantine Generals Problem&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;blockchain-protocol&quot;&gt;2.1 Blockchain protocol&lt;/h4&gt;
&lt;p&gt;Bitcoin uses Blockchain to record the transactions. Thus, Blockchain needs protocol to sync the blocks for nodes in the network. Suppose there is somehow an ability to pick a random node in the system (in Bitcoin, this random node is picked by a procedure called mining), this node gets to propose the next block in the chain. Here is the simplified protocol.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Bitcoin consensus algorithm (simplified)&lt;/b&gt;&lt;br /&gt;
This algorithm is simplified in that it assumes the ability to select a random node in a manner that is not vulnerable to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sybil_attack&quot;&gt;Sybil attacks&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;New transactions are broadcast to all nodes&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each node collects new transactions into a block&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In each round a random node gets to broadcast its block&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other nodes accept the block only if all transactions in it are valid (unspent, valid signatures)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nodes express their acceptance of the block by including its hash in the next block they create&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By this manner, the system is robust enough to prevent potential attacks which we will talk about later. First, we will talk about how other nodes process the block they received a block(step 4 and step 5).&lt;/p&gt;

&lt;h4 id=&quot;receive-block&quot;&gt;2.1.1 Receive block&lt;/h4&gt;
&lt;p&gt;When receiving a new block message broadcasted from step 3, the node should extend the blockchain they are maintaining. There are three kinds of blocks in the blockchain:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;blocks in the main branch. The transactions in these blocks are considered at least tentatively confirmed&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;blocks on side branches off the main branch. These blocks have at least tentatively lost the race to be in the main branch&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;orphan blocks. These are blocks which don’t link into the main branch, normally because of a missing predecessor or nth-level predecessor.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The largest branch in the blockchain is called the main branch. When receiving a new block, the node will try to add this into main branch, side branches or orphan block pool depending on the hash pointer. After adding it, three cases will arise:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;block further extends the main branch;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block extends a side branch but does not add enough difficulty to make it become the new main branch;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block extends a side branch and makes it the new main branch.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Depending on which case happens, the blockchain takes different actions. An overview of the actions is available at &lt;a href=&quot;https://en.bitcoin.it/wiki/Protocol_rules&quot;&gt;protocol&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;advantages&quot;&gt;2.1.2 Advantages&lt;/h4&gt;
&lt;p&gt;The protocol can prevent many kinds of attacks. Let’s now try to understand why this consensus algorithm works. To do this, let’s consider how a malicious adversary — who we’ll call Alice — may be able to subvert this process.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Stealing Bitcoins.&lt;/b&gt; Can Alice simply steal bitcoins belonging to another user at an address she doesn’t control? No. Even if it is Alice’s turn to propose the next block in the chain, she cannot steal other users’ bitcoins. Doing so would require Alice to create a valid transaction that spends that coin. This would require Alice to forge the owners’ signatures which she cannot do if a secure digital signature scheme is used. So as long as the underlying cryptography is solid, she’s not able to simply steal bitcoins.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Denial of service attack.&lt;/b&gt; Let’s consider another attack. Say Alice really dislikes some other user Bob. Alice can then decide that she will not include any transactions originating from Bob’s address in any block that she proposes to get onto the block chain. In other words, she’s denying service to Bob. While this is a valid attack that Alice can try to mount, luckily it’s nothing more than a minor&lt;br /&gt;
annoyance. If Bob’s transaction doesn’t make it into the next block that Alice proposes, he will just wait until an honest node gets the chance to propose a block and then his transaction will get into that block. So that’s not really a good attack either.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Double-spend attack.&lt;/b&gt; Let’s assume that Alice is a customer of some online merchant or website run by Bob, who provides some online service in exchange for payment in bitcoins. Let’s say Bob’s service allows the download of some software. So here’s how a double-spend attack might work. Alice adds an item to her shopping cart on Bob’s website and the server requests payment. Then Alice creates a Bitcoin transaction from her address to Bob’s and broadcasts it to the network. Let’s say that some honest node creates the next block, and includes this transaction in that block. So there is now a block that was created by an honest node that contains a transaction that represents a payment from Alice to the merchant Bob. The graph below shows the effect to Blockchain.&lt;br /&gt;
&lt;img src=&quot;/images/post2/doublespend.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And how do we know if this double spend attempt is going to succeed or not? Well, that depends on which block will ultimately end up on the long-term consensus chain — the one with the Alice → Bob transaction or the one with the Alice → Alice transaction. What determines which block will be included? Honest nodes follow the policy of extending the longest valid branch, so which branch will they extend? There is no right answer! At this point, the two branches are the same length — they only differ in the last block and both of these blocks are valid. The node that chooses the next block then may decide to build upon either one of them. Thus, only one of two transactions will finally be kept in the blockchain. Alice cannot achieve double-spend attack in this context. The merchart Bob can wait confirmations for transactions to decide whether let Alice download the software. Thus, the protocol can prevent double-spend attack.&lt;/p&gt;

&lt;h3 id=&quot;pick-up-a-random-node&quot;&gt;3. Pick up a random node&lt;/h3&gt;
&lt;p&gt;In this section, we will talk about how to randomly choose a node from the network. Nodes in the network are rewarded by being chosen as this node. Thus, this motivates people to get the opportunity for being chosen through ‘mining’. The rewards include the creation of new coins and transaction fees. At the time of this writing, the value of the block reward is fixed at 25 Bitcoins. But it actually halves every 210,000 blocks. Based on the rate of block creation that we will see shortly, this means that the rate drops roughly every four years (because in expection, a new block is generated every 10 minutes). We’re now in the second period. For the first four years of Bitcoin’s existence, the block reward was 50 bitcoins; now it’s 25. The node chosen will get 25 newly created Bitcoins. &lt;br /&gt;
&lt;img src=&quot;/images/post2/reward.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;br /&gt;
Now, we introduce how the node is chosen through ‘mining’. The node is chosen through proof-of-work. The key idea behind proof-of-work is that we approximate the selection of a random node by instead selecting nodes in proportion to a resource that we hope that nobody can monopolize. If, for example, that resource is computing power, then it’s a proof-of-work system.&lt;/p&gt;

&lt;p&gt;Bitcoin achieves proof-of-work using hash puzzles. In order to create a block, the node that proposes that block is required to find a number, or nonce, such that when you concatenate the nonce, the previous hash, and the list of transactions that comprise that block and take the hash of this whole string, then that hash output should be a number that falls into a target space that is quite small in relation to the much larger output space of that hash function. We can define such a target space as any value falling below a certain target value. In this case, the nonce will have to satisfy the inequality:&lt;/p&gt;
&lt;center&gt;H(nonce || prev_hash || tx || tx || ... || tx) &amp;lt; target.&lt;/center&gt;

&lt;p&gt;The first node which finds this nounce proposes the block. Thus, in order to be chosen, the node should have a great computing power. The incentive to get Bitcoins flourishes the Bitcoin mining industry.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;This post introduces how Bitcoin achieves concensus and how to choose random node to propose next block. In next post, we will introduce the data format of blocks.&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/16/Blockchain-and-Bitcoin-(2).html</link>
        <guid isPermaLink="true">/2016/07/16/Blockchain-and-Bitcoin-(2).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>consensus-algorithm</category>
        
        <category>double-spend-attack</category>
        
        <category>decentralisation</category>
        
        
      </item>
    
      <item>
        <title>Blockchain and Bitcoin (1)</title>
        <description>&lt;h3 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h3&gt;
&lt;p&gt;Bitcoin is a peer-to-peer digital asset and a payment system. The system is invented by &lt;a href=&quot;https://en.wikipedia.org/wiki/Satoshi_Nakamoto&quot;&gt;Satoshi Nakamoto&lt;/a&gt; and released as an open-source software in 2009.&lt;/p&gt;

&lt;p&gt;Bitcoins are created as a reward for payment processing work in which users offer their computing power to verify and record payments into a public ledger. This activity is called mining and miners are rewarded with transaction fees and newly created bitcoins. Besides being obtained by mining, bitcoins can be exchanged for other currencies, products, and services.&lt;/p&gt;

&lt;p&gt;Bitcoin is revolutionising they way people pay and exchange products. In former days, currency is created and exchanged based on trusted institutions. The central bank issues currency and people make their payments via various ways such as commercial bank, PayPal, Alipay, Apple Wallet, etc. This centralised scheme has its own problems like counterfeit. On the contrary, In bitcoin system, transactions take place between users directly, without an intermediary. These transactions are verified by network nodes and recorded in a public distributed ledger called the blockchain.&lt;/p&gt;

&lt;p&gt;This blog series is based on some excellent books and tutorials such as &lt;a href=&quot;http://shop.oreilly.com/product/0636920032281.do&quot;&gt;Master Bitcoin&lt;/a&gt; and &lt;a href=&quot;https://www.coursera.org/learn/cryptocurrency&quot;&gt;Bitcoin and Cryptocurrency Technologies&lt;/a&gt;. The &lt;a href=&quot;https://en.bitcoin.it/wiki/Protocol_documentation&quot;&gt;official documentation&lt;/a&gt; of bitcoin is also very helpful.&lt;/p&gt;

&lt;p&gt;In the first post, we give some introduction on data structures and cryptography concepts used in blockchain and bitcoin.&lt;/p&gt;

&lt;h3 id=&quot;cryptographic-hash-function&quot;&gt;2. Cryptographic Hash function&lt;/h3&gt;

&lt;h4 id=&quot;properties&quot;&gt;2.1 Properties&lt;/h4&gt;
&lt;p&gt;Cryptographic Hash function is used often in blockchain. For a hash function, it takes variable length input &lt;em&gt;x&lt;/em&gt; and map it to a fixed size output &lt;em&gt;H(x)&lt;/em&gt; (e.g. 256 bits for MD5 and SHA-256). A hash function must have three properties to become a cryptographic hash function:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Collision-resistance: A hash function &lt;em&gt;H&lt;/em&gt; is said to be collision resistant if it is infeasible to find two values, &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; , such that &lt;em&gt;x != y&lt;/em&gt; , yet &lt;em&gt;H(x)= H(y)&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hiding: A hash function &lt;em&gt;H&lt;/em&gt; is hiding if: when a secret value &lt;em&gt;r&lt;/em&gt; is chosen from a probability distribution that has high entropy, then given &lt;em&gt;H(r ‖ x)&lt;/em&gt; it is infeasible to find &lt;em&gt;x&lt;/em&gt;. &lt;em&gt;‖&lt;/em&gt; means concatenation of two strings.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Puzzle friendliness. A hash function &lt;em&gt;H&lt;/em&gt; is said to be puzzle-friendly if for every possible n-bit output value &lt;em&gt;y&lt;/em&gt; , if &lt;em&gt;k&lt;/em&gt; is chosen from a distribution with high entropy, then it is infeasible to find &lt;em&gt;x&lt;/em&gt; such that &lt;em&gt;H(k ‖ x) = y&lt;/em&gt; in time significantly less than &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given three properties, those hash functions can have a lot of practical applications. Hiding and puzzle friendliness guaranttee that it is infeasible to reverse-engineer intput &lt;em&gt;x&lt;/em&gt; given hash value &lt;em&gt;H(x)&lt;/em&gt;. In Blockchain system, SHA-256 is the hardcore of the system. Given a data block, SHA-256 maps the data block to 256 bits. According to collision-resistance, since it is infeasible to find two different values that are mapped to the same hash value, we can safely use the 256 bits as the ID of the data block. SHA-256 is generated by a procedure called &lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction&quot;&gt;Merkle-Damgard transform&lt;/a&gt;. The procedure is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/sha256.png&quot; width=&quot;400&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hash-pointers&quot;&gt;2.2 Hash Pointers&lt;/h4&gt;
&lt;p&gt;A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. Whereas a regular pointer gives you a way to retrieve the information, a hash pointer also gives you a way to verify that the information hasn’t changed. In regular pointer such as in C/C++, the pointer stores the variable address. In a hash pointer, it simply stores the hash value &lt;em&gt;H(x)&lt;/em&gt; of the data &lt;em&gt;x&lt;/em&gt; it points to. An example is shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/hashpointer.png&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In practice, the hash pointers can be indexed by database or structures like hash table to support efficient retrieval. Given hash pointers, we can use it to build all kinds of data structures. Intuitively, we can take a familiar data structure that uses pointers such as a linked list or a binary search tree and implement it with hash pointers, instead of pointers as we normally would. Here is two examples on blockchain and merkle tree.&lt;/p&gt;

&lt;h5 id=&quot;blockchain&quot;&gt;2.2.1 Blockchain&lt;/h5&gt;
&lt;p&gt;Blockchain is just a linked list using hash pointers. Whereas as in a regular linked list where you have a series of blocks, each block has data as well as a pointer to the previous block in the list, in a block chain the previous block pointer will be replaced with a hash pointer. So each block not only tells us where the value of the previous block was, but it also contains a digest of that value that allows us to verify that the value hasn’t changed. We store the head of the list, which is just a regular hash-pointer that points to the most recent data block.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post1/blockchain.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structures have the property that it is a tamper-evident log, i.e., if the attacher changes the data in the middle, he has to continue changing the hash pointers until the root of the blockchain. In a distributed environment, if others store a copy of the root of the blockchain, it can easily detect the blockchain in the attacker’s machine has been tampered.&lt;/p&gt;

&lt;h5 id=&quot;merkle-trees&quot;&gt;2.2.2 Merkle trees&lt;/h5&gt;
&lt;p&gt;Another useful data structure that we can build using hash pointers is a binary tree. A binary tree with hash pointers is known as a Merkle tree, after its inventor Ralph Merkle. Suppose we have a number of blocks containing data. These blocks comprise the leaves of our tree. We group these data blocks into pairs of two, and then for each pair, we build a data structure that has two hash pointers, one to each of these blocks. These data structures make the next level up of the tree. We in turn group these into groups of two, and for each pair, create a new data structure that contains the hash of each. We continue doing this until we reach a single block, the root of the tree. For example, suppose we have three data blocks, &lt;em&gt;a, b, c&lt;/em&gt;. We can generate a merkle tree by doing the following steps:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d1 = dhash(a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d2 = dhash(b)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d3 = dhash(c)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d4 = dhash(c)&lt;/em&gt; &lt;em&gt;#since we have odd number of blocks, we append it with another c&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d5 = dhash(d1 ‖ d2)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d6 = dhash(d3 ‖ d4)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;d7 = dhash(d5 ‖ d6)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is graphical example of merkle tree with 8 data blocks.&lt;br /&gt;
&lt;img src=&quot;/images/post1/merkle.png&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Based on the structure of merkle, it can check the membership of data in &lt;em&gt;O(logn)&lt;/em&gt; time and &lt;em&gt;O(logn)&lt;/em&gt; space. Here is a nice post from &lt;a href=&quot;https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work&quot;&gt;Quora&lt;/a&gt; illustrating why.&lt;/p&gt;

&lt;h3 id=&quot;signatures&quot;&gt;3. Signatures&lt;/h3&gt;
&lt;p&gt;A digital signature is supposed to be the digital analog to a handwritten signature on paper. We desire two properties from digital signatures that correspond well to the handwritten signature analogy. Firstly, only you can make your signature, but anyone who sees it can verify that it’s valid. Secondly, we want the signature to be tied to a particular document so that the signature cannot be used to indicate your agreement or endorsement of a different document. For handwritten signatures, this latter property is analogous to assuring that somebody can’t take your signature and snip it off one document and glue it onto the bottom of another one.&lt;/p&gt;

&lt;p&gt;In practice, the signature is usually implemented as private-public key encryption. The popular algorithm is &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot;&gt;RSA&lt;/a&gt;. A digital signature scheme consists of the following three algorithms:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;(sk, pk) := generateKeys(keysize)&lt;/em&gt; The generateKeys method takes a key size and generates a key pair. The secret key &lt;em&gt;sk&lt;/em&gt; is kept privately and used to sign messages. &lt;em&gt;pk&lt;/em&gt; is the public verification key that you give to everybody. Anyone with this key can verify your signature.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;sig := sign(sk, message)&lt;/em&gt; The sign method takes a message, &lt;em&gt;msg&lt;/em&gt;, and a secret key, &lt;em&gt;sk&lt;/em&gt;, as input and outputs a signature for the &lt;em&gt;msg&lt;/em&gt; under &lt;em&gt;sk&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;isValid := verify(pk, message, sig)&lt;/em&gt; The verify method takes a message, a signature, and a public key as input. It returns a boolean value, &lt;em&gt;isValid&lt;/em&gt;, that will be true if &lt;em&gt;sig&lt;/em&gt; is a valid signature for message under public key &lt;em&gt;pk&lt;/em&gt;, and false otherwise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We require that the following two properties hold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Valid signatures must verify: &lt;em&gt;verify(pk, message, sign(sk, message))== true&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Signatures are existentially unforgeable&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With signature, the receiver of the message can verify the validity.&lt;/p&gt;

&lt;h3 id=&quot;final-remarks&quot;&gt;4. Final remarks&lt;/h3&gt;
&lt;p&gt;Given the building blocks of blockchain and bitcoin, in next post, we will introduce the consensus and decentralisation schemes of blockchain and other more advanced features.&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jul 2016 00:00:00 +0800</pubDate>
        <link>/2016/07/12/Blockchain-and-Bitcoin-(1).html</link>
        <guid isPermaLink="true">/2016/07/12/Blockchain-and-Bitcoin-(1).html</guid>
        
        <category>blockchain</category>
        
        <category>bitcoin</category>
        
        <category>data-structure</category>
        
        <category>cryptography</category>
        
        
      </item>
    
  </channel>
</rss>
